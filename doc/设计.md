
# 设计

## 1.用户管理

## 2.地图管理

## 3.游戏管理

### 1.游戏的核心控制

+ 游戏的核心控制是基于事件指令的;

+ 客户端（web前端，移动前端...）根据用户的操作发出事件(事件集)，后端处理事件，生成指令(指令集)，
前端再根据指令做出相应的渲染;

+ 其中后端维护一局游戏的生命周期，即GameContext 维护在GameContextManger中;

+ 客户端对操作做出校验，校验成功通过simp(WS)发出事件，后端接受事件，封装成事件对象，分发到相应的GameContext，
GameContext获取对应事件的处理器，处理事件，返回结果，生成相应指令；

### 2.事件指令模型的好处
+ 可以不关心客户端，只需要接受事件，处理事件，方便多个平台

+ 便于联机，很多时候一个指令是需要发送到多个客户端显示的

## 4.联机管理

暂无

## 5.人机管理

### 1.人机操作
+ 当GameContextManger判断当前回合是人机回合的时候，会新生成一个GameRobot 对象
这是一个线程，从创建到结束取决于自身的逻辑


## 5.客户端管理

+ 客户端抽离出公共部分，包括对命令的解析等

+ 网页web使用VUE


## 6.扩展

+ 因为一个应用维护的都是有状态的（维护了不同的GameContext） 如果无状态需要频繁操作数据库，
且前端也每次都要传大Map过来，暂时不扩展

+ 模块化
    + common 通用模块
    + auth 人员管理及验证模块
    + base 基础模块，维护地图信息等
    + core 维护核心处理模块
        + 网络请求
    + robot 机器人模块
    + startup 启动模块
    

## 7.其他

#### 事件集




#### 待修改
后端：
减少复杂性 
1.移除mongo
2.移除mq
3.模块化

前端，后端 game
改成 事件指令模型

状态管理
主状态，子状态
可扩展性
概念定义好

